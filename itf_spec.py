# Client QoS Spec File Interface
# Author: Deyuan Guo
# Date: Dec 9, 2015

class QosSpec:
    def __init__(self):
        # hard requirements
        self.Availability = 99          # (int) an integer with a presumed leading 0
        self.Reliability = 90           # (int) an integer with a presumed leading 0
        self.ReservedSize = 0           # (int) MB
        self.DataIntegrity = 0          # (int) range 0 to 10**6, 0 is worst
        # flexible requirements
        self.Bandwidth = 'Low'          # (str) 'High' or 'Low'
        self.Latency = 'Low'            # (str) 'High' or 'Low'
        # extra information
        self.PhysicalLocation = ''      # (str) hierarchical phisical location

    # Read a spec file
    def read_from_file(self, path):
        try:
            with open(path, 'r') as f:
                spec = f.read().splitlines()
                for line in spec:
                    info = line.split('#')[0].split(',')
                    if len(info) < 2:
                        continue
                    key = info[0].strip()
                    val = info[1].strip()
                    if val == '':
                        continue
                    if key == 'Availability':
                        self.Availability = int(float(val))
                    elif key == 'Reliability':
                        self.Reliability = int(float(val))
                    elif key == 'ReservedSize':
                        self.ReservedSize = int(float(val))
                    elif key == 'DataIntegrity':
                        self.DataIntegrity = int(float(val))
                    elif key == 'Bandwidth':
                        if val == 'high' or val == 'High' or val == 'HIGH':
                            self.Bandwidth = 'High'
                        else:
                            self.Bandwidth = 'Low'
                    elif key == 'Latency':
                        if val == 'high' or val == 'High' or val == 'HIGH':
                            self.Latency = 'High'
                        else:
                            self.Latency = 'Low'
                    elif key == 'PhysicalLocation':
                        # a list of locaiton separated by ','
                        self.PhysicalLocation = []
                        for i in range(1, len(info)):
                            self.PhysicalLocation.append(info[i].strip())
            return True
        except:
            print '[QoS Spec] Error: Cannot parse' + path
            return False

    # Generate a multi-line string
    def to_string(self):
        spec = '# Client QoS spec file. Generated by qmsim.\n' \
             + 'Availability'     + ', ' + str(self.Availability      ) + '\n' \
             + 'Reliability'      + ', ' + str(self.Reliability       ) + '\n' \
             + 'ReservedSize'     + ', ' + str(self.ReservedSize      ) + '\n' \
             + 'DataIntegrity'    + ', ' + str(self.DataIntegrity     ) + '\n' \
             + 'Bandwidth'        + ', ' + str(self.Bandwidth         ) + '\n' \
             + 'Latency'          + ', ' + str(self.Latency           ) + '\n' \
             + 'PhysicalLocation'
        if len(self.PhysicalLocation) == 0:
            spec += ', '
        else:
            for s in self.PhysicalLocation:
                spec += ', ' + s
        spec += '\n'
        return spec

    # Write spec to a file
    def write_to_file(self, path):
        try:
            with open(path, 'w') as f:
                spec = self.to_string()
                f.write(spec)
            return True
        except:
            print '[QoS Spec] Error: Cannot write to ' + path
            return False

# Testing
if __name__ == '__main__':
    spec = QosSpec()
    print spec.to_string()
    spec.write_to_file('temp.txt')
    spec.read_from_file('temp.txt')

