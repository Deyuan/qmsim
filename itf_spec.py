# Client QoS Spec File Interface
# Author: Deyuan Guo, Chunkun Bo
# Date: Dec 9, 2015

class QosSpec:
    def __init__(self, spec_tuple=None):
        if spec_tuple is None:
            self.SpecId = ''           # (str) a unique string
            # hard requirements
            self.Availability = 99     # (int) an integer with a presumed leading 0
            self.Reliability = 99      # (int) an integer with a presumed leading 0
            self.ReservedSize = 100    # (int) MB
            self.UsedSize = 0          # (int) MB
            self.DataIntegrity = 0     # (int) range 0 to 10**6, 0 is worst
            # flexible requirements
            self.Bandwidth = 'Low'     # (str) 'High' or 'Low'
            self.Latency = 'High'      # (str) 'High' or 'Low'
            # extra information
            self.PhysicalLocations = '' # (str) locations separated by ;
            self.SpecPath = ''          # (str) grid path to the spec file
        else:
            self.SpecId, \
            self.Availability, \
            self.Reliability, \
            self.ReservedSize, \
            self.UsedSize, \
            self.DataIntegrity, \
            self.Bandwidth, \
            self.Latency, \
            self.PhysicalLocations, \
            self.SpecPath = spec_tuple
            # convert unicode string into regular string
            self.SpecId = str(self.SpecId)
            self.Bandwidth = str(self.Bandwidth)
            self.Latency = str(self.Latency)
            self.PhysicalLocations = str(self.PhysicalLocations)
            self.SpecPath = str(self.SpecPath)

    # Parse spec from a string
    def parse_string(self, spec_string):
        if spec_string == '':
            return -1
        spec = spec_string.splitlines()
        for line in spec:
            info = line.split('#')[0].split(',')
            if len(info) < 2:
                continue
            key = info[0].strip()
            val = info[1].strip()
            if key == '' or val == '':
                continue
            if key == 'SpecId':
                self.SpecId = val
            elif key == 'Availability':
                self.Availability = int(float(val))
            elif key == 'Reliability':
                self.Reliability = int(float(val))
            elif key == 'ReservedSize':
                self.ReservedSize = int(float(val))
            elif key == 'UsedSize':
                self.UsedSize = int(float(val))
            elif key == 'DataIntegrity':
                self.DataIntegrity = int(float(val))
            elif key == 'Bandwidth':
                if val == 'high' or val == 'High' or val == 'HIGH':
                    self.Bandwidth = 'High'
                else:
                    self.Bandwidth = 'Low'
            elif key == 'Latency':
                if val == 'high' or val == 'High' or val == 'HIGH':
                    self.Latency = 'High'
                else:
                    self.Latency = 'Low'
            elif key == 'PhysicalLocations':
                # a list of locaiton separated by ';'
                self.PhysicalLocations = val
            elif key == 'SpecPath':
                self.SpecPath = val
            else:
                print '[itf_spec] Warning: Cannot parse: ' + line
                return -1;
        return 0

    # Read spec from a file
    def read_from_file(self, path):
        try:
            f = open(path, 'r')
        except:
            print '[itf_spec] Error: Cannot parse ' + path
            return False
        spec = f.read()
        self.parse_string(spec)
        f.close()
        self.SpecPath = path
        return True

    # Generate a multi-line string
    def to_string(self):
        spec = '# Client QoS spec file. Generated by qmsim.\n' \
             + 'SpecId'        + ', ' + str(self.SpecId       ) + '\n' \
             + 'Availability'  + ', ' + str(self.Availability ) + '\n' \
             + 'Reliability'   + ', ' + str(self.Reliability  ) + '\n' \
             + 'ReservedSize'  + ', ' + str(self.ReservedSize ) + '\t# MB\n' \
             + 'UsedSize'      + ', ' + str(self.UsedSize     ) + '\t# MB\n' \
             + 'DataIntegrity' + ', ' + str(self.DataIntegrity) + '\t# 0:worst\n' \
             + 'Bandwidth'     + ', ' + str(self.Bandwidth    ) + '\t# High or Low\n' \
             + 'Latency'       + ', ' + str(self.Latency      ) + '\t# High or Low\n' \
             + 'PhysicalLocations' + ',' + str(self.PhysicalLocations) + '\n' \
             + 'SpecPath'      + ',' + str(self.SpecPath) + '\n'
        return spec

    # Get physical location list
    def get_locations(self):
        locations = []
        loc_str = self.PhysicalLocations
        loc_list = loc_str.split(';')
        for loc in loc_list:
            locations.append(loc.strip())
        return locations

    # Write spec to a file
    def write_to_file(self, path):
        try:
            with open(path, 'w') as f:
                spec = self.to_string()
                f.write(spec)
            return True
        except:
            print '[QoS Spec] Error: Cannot write to ' + path
            return False

    # Generate a tuple for inserting to SQLite database
    def to_tuple(self):
        return (self.SpecId       ,
                self.Availability ,
                self.Reliability  ,
                self.ReservedSize ,
                self.UsedSize     ,
                self.DataIntegrity,
                self.Bandwidth    ,
                self.Latency      ,
                self.PhysicalLocations,
                self.SpecPath     )


# A string for creating the specification table in sqlite
def get_sql_header():
    header = " Specifications(" + \
             "SpecId            TEXT PRIMARY KEY UNIQUE," + \
             "Availability      INT," + \
             "Reliability       INT," + \
             "ReservedSize      INT," + \
             "UsedSize          INT," + \
             "DataIntegrity     INT," + \
             "Bandwidth         TEXT," + \
             "Latency           TEXT," + \
             "PhysicalLocations TEXT," + \
             "SpecPath          TEXT" + \
             ");"
    return header

# Testing
if __name__ == '__main__':
    spec = QosSpec()
    spec_str = spec.to_string()
    print spec_str
    spec.parse_string(spec_str)
    spec.write_to_file('spec.txt')
    spec.read_from_file('spec.txt')

